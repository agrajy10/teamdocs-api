# Infra: AWS CDK Stack for teamdocs-api

This folder contains an AWS CDK (v2) app that provisions the infrastructure required to run the `teamdocs-api` application.

The CDK app is implemented using **ES modules** and lives entirely in this `infra` subproject so that infra concerns stay separate from application code.

This file is also used as a convenient place to trigger infra-only deployments via the `Deploy Infra` GitHub Actions workflow whenever it changes.

## High-Level Architecture

The stack (`TeamdocsInfraStack`) creates:

- A new VPC with public and private isolated subnets
- An ECR repository to store the application Docker image
- A single EC2 instance (t2.micro, Amazon Linux 2023) in a public subnet
- Security groups that:
  - Allow SSH (22), HTTP (80), and app traffic (3000) from the internet to the EC2 instance
  - Allow PostgreSQL (5432) only from the EC2 security group to the database
- An RDS PostgreSQL instance (t3.micro, free tier–eligible) in private isolated subnets
- A custom RDS parameter group that disables enforced SSL (`rds.force_ssl = 0`)
- AWS Secrets Manager secrets for:
  - RDS database credentials (auto-generated)
  - API environment variables (NODE_ENV, SESSION_SECRET)
- IAM permissions for the EC2 instance to pull images from ECR and read secrets from Secrets Manager
- CloudFormation outputs with useful connection information

## Project Structure

- `package.json` – CDK app manifest, marked with `"type": "module"` for ESM
- `cdk.json` – CDK configuration; tells CDK how to run the app
- `bin/teamdocs-infra.js` – CDK entrypoint (creates the app and stack)
- `lib/teamdocs-infra-stack.js` – Stack definition and all AWS resources

## Resources in Detail

### VPC

- Construct: `AppVpc`
- Configuration:
  - `maxAzs: 2`
  - `natGateways: 0`
  - Subnets:
    - Public subnets (for EC2)
    - Private isolated subnets (for RDS)

### ECR Repository

- Construct: `AppRepository`
- Name: `teamdocs-api`
- Purpose: Stores the Docker image for the `teamdocs-api` service.
- Output:
  - `EcrRepositoryUri` – Full ECR URI used for tagging and pushing the image..

### EC2 Instance

- Construct: `AppInstance`
- Type: `t2.micro`
- AMI: Latest **Amazon Linux 2023** (x86_64)
- Subnet: Public subnet in the VPC
- Security group: `Ec2SecurityGroup`
- IAM role: `Ec2InstanceRole`
  - Managed policy: `AmazonEC2ContainerRegistryReadOnly` (pull from ECR)
  - Read access to RDS credentials secret
  - Read access to API environment variables secret

#### EC2 Security Group (Ec2SecurityGroup)

Ingress rules:

- `tcp/22` from `0.0.0.0/0` – SSH
- `tcp/80` from `0.0.0.0/0` – HTTP
- `tcp/3000` from `0.0.0.0/0` – Application port (matches the node app)

### EC2 UserData

The EC2 instance is configured with a UserData script that automatically sets up and runs the application:

1. Updates system packages
2. Installs Docker, AWS CLI, and jq
3. Enables and starts the Docker service
4. Fetches secrets from AWS Secrets Manager:
   - RDS database credentials (username, password, host, port)
   - API environment variables (NODE_ENV, SESSION_SECRET)
5. Constructs the `DATABASE_URL` from the fetched credentials
6. Creates `/etc/teamdocs-api.env` file with all environment variables
7. Logs in to ECR using the instance's IAM role
8. Pulls the Docker image tagged `:latest` from the created ECR repository
9. Stops and removes any existing container with the same name
10. Starts the application container with:
    - Environment variables loaded from `/etc/teamdocs-api.env`
    - Port 3000 exposed and mapped
    - Automatic restart policy (`--restart unless-stopped`)

The application starts automatically on instance launch and will restart on reboot.

### RDS PostgreSQL

- Construct: `AppDatabase`
- Engine: PostgreSQL 18
- Instance type: `t3.micro` (free tier–eligible)
- Storage: 20 GB
- AZs: Single AZ (no Multi-AZ)
- Subnets: Private isolated subnets in the same VPC
- Public accessibility: `false` (no public internet access)
- Credentials:
  - Generated by CDK (`fromGeneratedSecret('postgres')`)
  - Stored in AWS Secrets Manager

#### DB Parameter Group

- Construct: `PostgresParams`
- Engine: PostgreSQL 18
- Parameters:
  - `rds.force_ssl = 0` – Disables enforced SSL connections (as requested)

> Note: Disabling SSL is not recommended for production environments. It is included here to satisfy the exercise requirements.

#### DB Security Group (DbSecurityGroup)

- Allows inbound `tcp/5432` from `Ec2SecurityGroup` only.
- The database is not reachable from the public internet.

### Secrets Manager

#### RDS Credentials Secret

- Auto-generated by CDK when creating the RDS instance
- Contains: username, password, host, port, and dbname
- Read access granted to `Ec2InstanceRole`
- Fetched during EC2 UserData execution to build `DATABASE_URL`

#### API Environment Variables Secret

- Construct: `ApiEnvSecret`
- Name: `teamdocs-api-env`
- Contains:
  - `NODE_ENV`: Set to "production"
  - `SESSION_SECRET`: Auto-generated secure random string
- Read access granted to `Ec2InstanceRole`
- Fetched during EC2 UserData execution and written to `/etc/teamdocs-api.env`

### EC2 ↔ RDS Connectivity

- The EC2 instance runs in public subnets and uses `Ec2SecurityGroup`.
- The RDS instance runs in private isolated subnets and uses `DbSecurityGroup`.
- `DbSecurityGroup` has an ingress rule allowing Postgres traffic (`5432`) from `Ec2SecurityGroup`.
- Database credentials are fetched securely from Secrets Manager during instance startup.

### CloudFormation Outputs

The stack exports:

- `ApiEnvSecretArn` – ARN of the Secrets Manager secret containing API environment variables
- `Ec2PublicIp` – Public IP address of the EC2 instance (for SSH / HTTP access)
- `DatabaseEndpoint` – Hostname of the RDS PostgreSQL instance
- `EcrRepositoryUri` – URI of the ECR repository for building and pushing the image

## Running the CDK App

Prerequisites:

- Node.js and npm installed
- AWS CLI configured with credentials and default region
- CDK v2 available (`npx cdk` is sufficient)

From the repository root:

```bash
cd infra
npm install
```

Optional: synthesize the CloudFormation templates:

```bash
npx cdk synth
```

If this is your first CDK app in the target account/region:

```bash
npx cdk bootstrap
```

Deploy the stack:

```bash
npx cdk deploy
```

After deployment, note the outputs for:

- `ApiEnvSecretArn`
- `EcrRepositoryUri`
- `Ec2PublicIp`
- `DatabaseEndpoint`

## Pushing the Application Image to ECR

After the stack is deployed and you have the `EcrRepositoryUri`:

```bash
docker build -t <EcrRepositoryUri>:latest .
aws ecr get-login-password --region <region> \
  | docker login --username AWS --password-stdin <account>.dkr.ecr.<region>.amazonaws.com
docker push <EcrRepositoryUri>:latest
```

On the next EC2 boot or UserData re-execution, the script will pull the `:latest` image and start the container automatically.

## Post-Deployment Steps

After the infrastructure is deployed and the application container is running, you must manually run database migrations:

1. SSH into the EC2 instance:
   ```bash
   ssh -i <your-key.pem> ec2-user@<Ec2PublicIp>
   ```

2. Run the migration command in the running container:
   ```bash
   docker exec teamdocs-api npm run migrate up
   ```

3. Verify the migrations completed successfully.


## Cleanup

To remove all resources created by this stack:

```bash
cd infra
npx cdk destroy
```

This will delete the EC2 instance, RDS instance, VPC, security groups, and related resources. Be sure to back up any data you want to keep before destroying the stack.
