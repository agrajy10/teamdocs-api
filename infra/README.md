# Infra: AWS CDK Stack for teamdocs-api

This folder contains an AWS CDK (v2) app that provisions the infrastructure required to run the `teamdocs-api` application.

The CDK app is implemented using **ES modules** and lives entirely in this `infra` subproject so that infra concerns stay separate from application code.

This file is also used as a convenient place to trigger infra-only deployments via the `Deploy Infra` GitHub Actions workflow whenever it changes.

## High-Level Architecture

The stack (`TeamdocsInfraStack`) creates:

- A new VPC with public and private isolated subnets
- An ECR repository to store the application Docker image
- A single EC2 instance (t2.micro, Amazon Linux 2023) in a public subnet
- Security groups that:
  - Allow SSH (22), HTTP (80), and app traffic (3000) from the internet to the EC2 instance
  - Allow PostgreSQL (5432) only from the EC2 security group to the database
- An RDS PostgreSQL instance (t3.micro, free tier–eligible) in private isolated subnets
- A custom RDS parameter group that disables enforced SSL (`rds.force_ssl = 0`)
- IAM permissions for the EC2 instance to pull images from ECR and read DB credentials from Secrets Manager
- CloudFormation outputs with useful connection information

## Project Structure

- `package.json` – CDK app manifest, marked with `"type": "module"` for ESM
- `cdk.json` – CDK configuration; tells CDK how to run the app
- `bin/teamdocs-infra.js` – CDK entrypoint (creates the app and stack)
- `lib/teamdocs-infra-stack.js` – Stack definition and all AWS resources

## Resources in Detail

### VPC

- Construct: `AppVpc`
- Configuration:
  - `maxAzs: 2`
  - `natGateways: 0`
  - Subnets:
    - Public subnets (for EC2)
    - Private isolated subnets (for RDS)

### ECR Repository

- Construct: `AppRepository`
- Name: `teamdocs-api`
- Purpose: Stores the Docker image for the `teamdocs-api` service.
- Output:
  - `EcrRepositoryUri` – Full ECR URI used for tagging and pushing the image.

### EC2 Instance

- Construct: `AppInstance`
- Type: `t2.micro`
- AMI: Latest **Amazon Linux 2023** (x86_64)
- Subnet: Public subnet in the VPC
- Security group: `Ec2SecurityGroup`
- IAM role: `Ec2InstanceRole`
  - Managed policy: `AmazonEC2ContainerRegistryReadOnly` (pull from ECR)

#### EC2 Security Group (Ec2SecurityGroup)

Ingress rules:

- `tcp/22` from `0.0.0.0/0` – SSH
- `tcp/80` from `0.0.0.0/0` – HTTP
- `tcp/3000` from `0.0.0.0/0` – Application port (matches the node app)

### EC2 UserData

The EC2 instance is configured with a UserData script that:

1. Updates system packages
2. Installs Docker and the AWS CLI
3. Enables and starts the Docker service
4. Logs in to ECR using the instance’s IAM role
5. **Only pulls** the Docker image tagged `:latest` from the created ECR repository

It deliberately does **not** run `docker run` so that you can control container startup yourself (e.g., via systemd, ECS, or manual commands).

### RDS PostgreSQL

- Construct: `AppDatabase`
- Engine: PostgreSQL 16
- Instance type: `t3.micro` (free tier–eligible)
- Storage: 20 GB
- AZs: Single AZ (no Multi-AZ)
- Subnets: Private isolated subnets in the same VPC
- Public accessibility: `false` (no public internet access)
- Credentials:
  - Generated by CDK (`fromGeneratedSecret('postgres')`)
  - Stored in AWS Secrets Manager

#### DB Parameter Group

- Construct: `PostgresParams`
- Engine: PostgreSQL 16
- Parameters:
  - `rds.force_ssl = 0` – Disables enforced SSL connections (as requested)

> Note: Disabling SSL is not recommended for production environments. It is included here to satisfy the exercise requirements.

#### DB Security Group (DbSecurityGroup)

- Allows inbound `tcp/5432` from `Ec2SecurityGroup` only.
- The database is not reachable from the public internet.

### EC2 ↔ RDS Connectivity

- The EC2 instance runs in public subnets and uses `Ec2SecurityGroup`.
- The RDS instance runs in private isolated subnets and uses `DbSecurityGroup`.
- `DbSecurityGroup` has an ingress rule allowing Postgres traffic (`5432`) from `Ec2SecurityGroup`.
- Secrets Manager:
  - The RDS credentials secret grants read access to `Ec2InstanceRole`.
  - Application code on the instance can fetch DB credentials securely using the instance role and AWS SDK.

### CloudFormation Outputs

The stack exports:

- `Ec2PublicIp` – Public IP address of the EC2 instance (for SSH / HTTP access)
- `DatabaseEndpoint` – Hostname of the RDS PostgreSQL instance
- `EcrRepositoryUri` – URI of the ECR repository for building and pushing the image

## Running the CDK App

Prerequisites:

- Node.js and npm installed
- AWS CLI configured with credentials and default region
- CDK v2 available (`npx cdk` is sufficient)

From the repository root:

```bash
cd infra
npm install
```

Optional: synthesize the CloudFormation templates:

```bash
npx cdk synth
```

If this is your first CDK app in the target account/region:

```bash
npx cdk bootstrap
```

Deploy the stack:

```bash
npx cdk deploy
```

After deployment, note the outputs for:

- `EcrRepositoryUri`
- `Ec2PublicIp`
- `DatabaseEndpoint`

## Pushing the Application Image to ECR

After the stack is deployed and you have the `EcrRepositoryUri`:

```bash
docker build -t <EcrRepositoryUri>:latest .
aws ecr get-login-password --region <region> \
  | docker login --username AWS --password-stdin <account>.dkr.ecr.<region>.amazonaws.com
docker push <EcrRepositoryUri>:latest
```

On the next EC2 boot, the UserData script will log in to ECR and pull the `:latest` image automatically.

## Cleanup

To remove all resources created by this stack:

```bash
cd infra
npx cdk destroy
```

This will delete the EC2 instance, RDS instance, VPC, security groups, and related resources. Be sure to back up any data you want to keep before destroying the stack.
